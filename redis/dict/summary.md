## redis的字典实现比较重要的几个细节

### 字典的底层数据结构及冲突解决方式？

> 字典的底层数据结构是哈希表，冲突的解决方式使用的是拉链法。比如字典中先插入了a键值对，之后要插入一个b键值对，计算出b键值对的索引位置和a相同，这个时候就把他们通过指针联系起来。redis的哈希表中链表是单向的，所以为了效率考虑，每次都把新加入的元素插入到链表头，这样是因为刚插入的元素，在之后被访问的可能性要大一点。

### rehash操作

> 字典中保存着两个哈希表，其中第二个(ht[1])就是用来做rehash用的。rehash步骤如下

1. 为字典的ht[1]分配空间，分配的空间大小取决于要执行的操作，以及ht[0]包含的键值对的数量。  

 * 如果执行的是扩展操作，ht[1]的大小为第一个大于等于ht[0].used*2的2的n次幂
 * 如果执行的是收缩操作，ht[1]的大小为第一个大于等于ht[0].used的2的n次幂
 
2. 将保存在ht[0]上的键值对rehash到ht[1]上
3. 当ht[0]包含的键值对都移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并为ht[1]创建一个新的哈希表，为下一次的rehash做准备。

### 哈希表扩展和释放的时机

当以下任意一个条件满足时，程序开始自动对哈希表进行扩容操作：

* 服务器没有在执行bgsave或者bgrewriteaof命令，并且哈希表的负载因子大于等于1
* 服务器正在执行上述两个命令，并且哈希表的负载因子大于等于5

负载因子怎么计算呢？

    load_factor = ht[0].used / ht[0].size


为何上述两个命令会影响我们扩展时负载因子大小的选择？
>因为在上述两个命令执行的时候，redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制的策略来优化子进程的执行效率，所以在子进程存在期间，提高扩展负载因子大小，从而尽量避免在子进程存在期间进行哈希表扩容，这样可以避免不必要的内存写入。

哈希表的负载因子小于0.1时，会对哈希表进行收缩操作。

### 渐进式的rehash
rehash时，需要将ht[0]中的键值对rehash到ht[1]中，但是这是操作通常不是一次完成的，而是分多次、渐进式的完成的。

原因就是如果ht[0]中的键值对很多，那么将键值对一次性从ht[0]全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。

哈希表渐进rehash的步骤如下：

* 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
* 字典中维护一个索引计数器变量rehashidx，并把它的值设置为0，表示rehash正式开始
* rehash进行期间，每次对字典进行CRUD操作时，程序除了执行指定的操作外，还会顺道将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，rehash工作完成后，rehashidx的值被置为+1
* 随着字典操作的不断完成，最终在某个时刻，ht[0]的所有键值对都被rehash到ht[1]，这时程序将rehashidx的值置为-1，表示rehash操作已经完成

### 渐进式rehash操作执行期间的哈希表操作
> 渐进过程中会用到ht[0]和ht[1]两张表，所以字典的RUD操作会在两张表上进行，查找的话先在ht[0]找，找不到的话再去ht[1]找，每次的新增操作都在ht[1]上进行，这样保证ht[0]中的键值对数量是只增不减的，并最终随着rehash的操作变成一个空表。