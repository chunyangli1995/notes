>redis服务器是一个事件驱动程序，它主要处理文件事件和时间事件。

## 文件事件

Redis开发了自己的网络事件处理器，这个处理器被称为文件事件处理器：

* 使用IO多路复用程序来监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
* 当被监听的套接字准备好一些基本操作时，与操作对应的文件事件就会产生，这时文件处理器就会调用套接字之前关联好的事件处理器来处理这些时间

## 文件事件处理器的构成

> 套接字、IO多路复用程序、文件事件分派器以及事件处理器。

文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件，因为一个服务器通常会连接多个套接字，所以多个文件事件有可能并发的产生。

IO多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。

IO多路复用程序会将产生文件事件的套接字放到一个队列里，然后通过这个队列，以有序、同步，每次一个套接字的方式向文件事件分派器传送套接字，当上一个套接字产生的事件被处理完毕之后，IO多路复用程序才会继续向文件事件分派器传送下一个套接字。

服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了当某个事件发生时，服务器应该执行的动作。

**如果一个套接字即可读、又可写，服务器将先读套接字、再写套接字**

### 文件事件的处理器

Redis为文件事件编写了多个处理器，这些事件处理器分别用于处理不同的网络通信需求。

#### 连接应答处理器

Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE\_READABLE事件关联起来，当客户端连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引导连接应答处理器执行，并执行相应的套接字应答操作。

#### 命令请求处理器

这个处理器负责从套接字读入客户端发送的命令请求内容，当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端的套接字AE\_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE\_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。

#### 命令回复处理器

当服务器端有命令回复需要传给客户端的时候，服务器就会将客户端的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务端传来的命令回复时，就会产生AE\_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作。

## 时间事件

时间事件分为两类：

* 定时事件
* 周期性事件

一个时间事件的三个主要组成属性：

* id：服务器为时间事件创建的唯一全局id
* when：毫秒精度的unix时间戳，记录了时间事件的到达时间
* timeProc：时间事件处理器，一个函数，当时间事件到达时，服务器就会调用相应的处理器来处理事件。

一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值

* 如果时间事件处理器返回AE_NOMORE，那么这个事件为定时事件，该事件在到达一次后就被删除，之后不可到达。
* 如果返回一个非AE_NOMORE的值，那么这个事件就是周期性事件，每当一个时间事件到达的时候，服务器会根据时间事件处理器返回的值，对时间事件的when属性更新，让这个事件在一段时候后再次到达，并以这种方式一直更新并且运行下去。

### 实现

服务器将所有的时间事件放在一个无序链表中，每当时间事件处理器运行时，就会遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。

>无序链表不影响时间事件处理器的性能
>正常情况下的redis服务器只使用最多两个时间事件，所以无序链表基本是退化成指针来使用，不会有什么效率问题。

#### 时间事件应用的实例

持续运行的redis服务器需要定期对自身的资源和状态进行检查和调整，从而保证服务器可以长期、稳定的运行，这些定期操作由serverCron函数来执行。

## 时间的调度和执行

因为服务器同时存在文件事件和时间事件两种类型，所以服务器必须对这两种事件进行调度，决定何时处理文件事件，何时又处理时间事件，以及花多少时间来处理它们。

事件的调度和执行由aeProcessEvents函数负责，以下是该函数的伪代码表示：

    def aeProcessEvents():
		
		# 获取到达时间离当前时间最近的时间事件
		time_event = aeSearchNearestTimer()
		
		# 计算最接近的时间事件距离到达还有多少毫秒
		remaind_time = time_event.when - unix_ts_now()

		# 如果事件已到达 那么remaind_time的值可能为负数，将其设置为0
		if remaind_time < 0:
			remaind_time = 0

		# 根据remaind_time的值，创建timeval结构
		timeval = create_timeval_with_ms(remaind_time)

		# 阻塞并等待文件事件的产生，最大的阻塞时间由传入的remaind_time结构决定
		# 如果remaind_time的值为0， 那么aeApiPoll调用之后马上返回，不阻塞
		aeApiPoll(timeval)

		# 处理所有已产生的文件事件
		processFileEvents()

		# 处理所有已到达的文件事件
		processTimeEvents()


将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了redis服务器的主函数，以下是该函数的伪代码表示：

	def main():
		
		# 初始化服务器
		init_server()

		# 一直处理事件，直到服务器关闭为止
		while server_is_not_shutdown():
			aeProcessEvents()

		# 服务器关闭 执行清理操作
		clean_server()

事件的调度和执行规则

1. aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法可以避免服务器对时间事件进行频繁的轮询，也可以确保aeApiPoll函数不会阻塞太长时间
2. 因为文件事件是随机出现的，随着文件事件的不断执行，时间会不断地逼近时间事件所设置的时间，并最终来到到达时间。
3. 对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，不管是文件事件的处理器还是时间事件的处理器，它们都会尽可能的减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。
4. 因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一点。
