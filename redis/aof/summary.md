## AOF持久化

AOF持久化也是持久化保存数据库状态的一种方式，它和RDB保存方式的不同是它会把redis执行的每条命令保存到磁盘中。

## AOF持久化的实现

分三个步骤，命令追加、文件写入和文件同步。

### 命令追加

当AOF持久化功能处于打开状态时，服务器在执行完一个写命令时，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

### AOF文件的写入和同步

Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件负责一些需要定时执行的函数。

因为服务器在执行文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以服务器每次执行结束一个事件循环之前，都会考虑是否将aof_buf中的内容写入和保存到aof文件里面。

服务端配置的appendfsync值决定同步和写入的行为，各个选项如下：

* always：将aof_buf中的所有内容同步并写入到aof文件中
* everysec：将aof_buf的内容写入到aof文件，如果上次同步的时间距现在超过一秒钟，那么再次对aof文件进行同步，并且这个同步是由一个线程专门负责的。
* no：将aof_buf中的内容写入到aof文件，但并不对aof文件进行同步，何时同步由操作系统决定。

默认值是everysec

### AOF文件的载入和数据还原

Redis读取aof文件并且还原数据库的步骤如下：

* 创建一个不带网络连接的伪客户端，因为redis的命令只能在客户端上下文中执行，而载入aof文件时所使用的命令直接来源于aof文件，所以使用一个伪客户端来执行aof文件中的命令
* 从aof文件中分析并且取出一条写命令
* 使用伪客户端执行被写入的命令
* 循环执行2和3，直到aof文件中的所有写命令都被执行完毕。

## AOF重写

随着服务器运行时间的流逝，aof文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的aof文件很可能对redis服务器、甚至整个宿主计算机造成影响，并且aof文件的体积越大，使用aof来还原数据库需要的时间就越长。

为了解决这个问题，redis提供了aof重写功能，通过该功能，redis可以创建一个新的aof文件来替代旧有的aof文件，新老文件保存的数据库状态是一样的，但是新的aof文件不会包含任何浪费空间的冗余命令。

**具体时间就是去数据库读取某个键的值，然后用一条命令实现。**

## AOF后台重写

因为aof重写程序执行的时间会比较长，所以redis将aof重写程序放到一个子进程中去执行，两个目的：

* 子进程aof重写期间，父进程可以继续处理命令请求
* 子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

### 使用子进程的一个小问题 

因为子进程会在aof重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得当前的数据库状态和重写后的aof文件的所保存的数据库状态不一致。

**如何解决？**

redis服务器设置了一个aof重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当redis执行完一个写命令之后，它会同时将这个写命令发送给aof缓冲区和aof重写缓冲区。

子进程执行aof重写期间，服务器进程需要执行下面三个工作：

1. 执行客户端发来的命令
2. 将执行后的命令追加到aof缓冲区
3. 将执行后的命令追加到aof重写缓冲区

当子进程完成aof重写工作之后，它会向父进程发送一个信号，父进程在接收到信号之后，会调用一个信号处理函数，并执行以下工作：

1. 将aof重写缓冲区中的所有内容写入到新的aof文件里，这时新aof文件保存的数据库状态和当前服务器的数据库状态是一致的。
2. 对新的aof文件改名，原子的覆盖现有的aof文件，完成新旧两个文件的替换。