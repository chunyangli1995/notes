## 压缩列表用途？

是哈希键和列表键的底层实现之一。满足下面任一条件，就会采用压缩列表作为底层的实现

* 当一个列表键只包含少量的列表项，并且每个列表项不是小整数值，就是比较短的字符串。
* 当一个哈希键只包含少量的哈希键，并且每个键值对的键和值不是小整数就是长度比较短的字符串。

## 构成

为了节约内存而生，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值。

压缩列表的各个组成部分：

    zlbytes | zltail | zllen | entry1 | entry2 | ... | entryN | zlend

**zlbytes：**记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配，或者计算zlend的位置时候使用

**zltail：**记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的位置

**zllen：**记录压缩列表包含的节点的数量，当这个属性的值小于UINT16_MAX的时候，这个属性的值就是压缩列表的节点的数量，否则的话，节点的数量需要遍历整个压缩列表才能得出

**entryX：**压缩列表包含的各个节点，节点的长度由节点包含的内容决定

**zlend：**用于标记压缩列表的末端

## 压缩列表节点的组成

每个压缩列表节点可以保存一个整数值或者一个字节数组，每个节点都由三个部分组成：


### previous_entry\_length

记录了压缩列表的前一个节点的长度，属性的长度可以是一个字节或者五个字节。

* 如果前一节点的长度小于254字节，那么该属性的长度就是一个字节
* 否则，该属性的长度为5个字节，第一个字节的值为254，而之后的四个字节用于保存前一个节点的长度

因为该属性记录了前一个节点的字节长度，所以可以通过指针运算， 根据当前节点的起始位置来计算出前一个节点的起始位置。

压缩列表的从表尾到表头的遍历操作就是通过这个属性来完成的。

### encoding

节点的encoding属性记录了节点的content属性所保存的数据的类型以及长度。

* 值的最高位是00、01或者10的是字节数组编码，分别代表一字节、两字节、五字节长，数组的长度由编码去掉最高两位后的其他位记录
* 值的最高位是11的是整数编码，这个编码表示content属性保存着整数，整数值的类型和长度由编码除去最高两位之后的其他位记录


### content

content属性保存着节点的值，节点的值可以是一个字节数组或者整数，值的类型以及长度由encoding属性决定。

## 连锁更新

连锁更新其实就是说假设连续的几个节点，它们的长度都很接近254，但是都不到254，那么每一个节点的后面一个节点都可以用一个字节长的previous\_entry\_length属性来记录前一个节点，那么假设第一个节点的前面一个节点由<254变成>254字节，那么第一个节点的previous_entry\_length属性就要扩展到5字节，第二个节点跟着扩....一直到连续的第N个节点，这就是连锁更新。

最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度是O(N)。所以连锁更新的最坏时间复杂度是O(N^2)。

但是连锁更新出现的概率很低，出现连续好几个节点的概率更低，所以不必担心这个问题。


